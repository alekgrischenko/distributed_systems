* 101 способ приготовления RabbitMQ и немного о pipeline архитектуре
https://habrahabr.ru/company/oleg-bunin/blog/310418/

Павел Филонов
(его же доклад "Выбираем СУБД для хранения временных рядов", я слушал в живую).

Отличие "события" и "запроса":

С request'ом всегда связан кто-то, кто сидит на той стороне,
тот, кто его отправил, очень нетерпеливый человек, робот, браузер, программа,
он ждет от нас ответа.

Система, которая засылает в нас события, логи, метрики, статистики –
От нас не требуют мгновенного ответа на какой-то вопрос.
От нас просят суметь много и быстро их обработать, обработать их по-разному.

Сколько эта технология проживет?
Если они так быстро появляются, то они начнут примерно с такой же скоростью умирать.

С этой точки зрения RabbitMQ интересен не как продукт, а как технология,
которая опирается на протокол AMQP, более низлежащий слой,
который уже нашел достаточно неплохое свое применение.

Пользователи AMQP:
- Google, вообще, выпускает официальный анонс, что он просто свой SQS-сервис баз строит на основе RabbitMQ.
- Microsoft Azure просто реализует протокол AMQP, реализация у них явно, похоже, своя.
- VMware – один из родоначальников протокола AMQP и системы RabbitMQ, очень активно использует его внутри своих решений.

Преимущества:
- Асинхронная обработка
- Простое добавление обработчиков
- Гибкая маршрутизация
- Удобная отладка
- Масштабируемость читателей и писателей
- Масштабируемость брокера (у RabbitMQ хорошо)
- Устойчивость к перезагрузкам и отказам

Topic в 3 раза медленее Direct.
Consistent Hash быстрый.
Преимущество в том, что он работает с числами. Первые три работают со строками как ключами маршрутизации, а последний работает с числами.

Пакетная обработка. Apache Kafka и ZeroMQ -- из коробки.
(prefetch count -- это не оно?)

Переполнение очередей. Закон Литтла.
- сохранение на диск (чтобы обработать потом)
- блокирование писателей (back-pressure)
- ограничьте размер очередей и/или время жизни сообщений (load-shredding)

Есть встроенный механизм RabbitMQ flow control.
https://www.rabbitmq.com/flow-control.html

Система начинает вставлять случайное ожидание, специальным образом
подобранное при чтении сокета от паблишера, в каком-то смысле уменьшая
уже даже на сетевом уровне интенсивность приходящих от него сетевых
пакетов.

The connection is being blocked and unblocked several times per
second, in order to keep the rate of message ingress at one that the
rest of the server can handle.
From the client's perspective it should just look like the network
bandwidth to the server is lower than it actually is.

Как только очередь возвращается в свои рамки, этот стоп-сигнал убирается, писатель начинает работать в прежнюю силу.

Если это было что-то пиковое, временное, это нас спасет.
Если нет, и эта ситуация постоянна,
мы ее откладываем до самой границы системы – до точки входа.

Stateless filters.
Stateful filters, сумматоры, разного рода агрегаторы.

Способы шардинга:
- остаток от деленая на к-во очередей. Требует константного количества очередей, нельзя добавить/убрать очередь.
- В RabbitMQ есть целых 2 Sharding plugin’а
- consistent-hash-exchange – идет прямо в дефолтной инсталляции,
реализует консистентного хэширования,
позволяет динамически менять количество очередей
старается делать так, чтобы решардинг прошел как можно более мягко.


* Building a Distributed Data Ingestion System with RabbitMQ
https://www.youtube.com/watch?v=EUfSgYU_SFk
https://www.slideshare.net/HDConf/alvaro-videla-building-a-distributed-data-ingestion-system-with-rabbitmq

A`lvaro Videla
co-author "RabbitMQ in Action"
http://alvaro-videla.com/


** Intro to RabbitMQ

Multi Protocol Messaging Server
Open Source (MPL)
Polyglot
Written in Erlang/OTP
Community Plugins

Multi Protocol: AMQP, MQTT, STOMP.
https://blogs.vmware.com/vfabric/2013/02/choosing-your-messaging-protocol-amqp-mqtt-or-stomp.html

Rebar is history, rabbitmq is pre-history. Not so easy to develop plugins.

Polyglot. Use can use it from: Java, node.js, Erlang, PHP, Ruby, .NET, Haskell, Python and many others.

RabbitMQ Simulator Demo
http://tryrabbitmq.com/
https://github.com/RabbitMQSimulator/RabbitMQSimulator

Есть много видов exchange, реализованых плагинами.
В том числе module hash exchange и consistent hash exchange.


** The Problem

Erlang code samples for producer and consumer.

Possible issues if not use rabbitmq but implement message queue. List of 6 points.

RabbitMQ Federation

можно построить разную топологию (дерево, кольцо и т.д.)

- support replication across different administrative domains
- support mix of erlang and rabbitmq versions
- support network partitions
- specificity - not everything has to be federated

Sample how to enable and configure.

expires, message-ttl, max-hops

Speed vs No Message Loss: ack-mode (on-confirm/on-publish/no-ack)

Recomended Reading:
Performance Modeling and Design of Computer Systems: Queueing Theory in Action
https://www.amazon.com/Performance-Modeling-Design-Computer-Systems/dp/1107027500


The Problem:
- Queues contents live in the node where the Queue was declared
- A cluster can access the queue from every connected node
- Queues are an Erlang processes
- Adding more nodes doesn't really help
(только я не понял, почему все перечисленое является проблемой)


** Solution

Sharded Queues
- declare queue with name nodename.queuename.index
- bind the queues to a partitioner exchange
- transparent to consumer (virtual queue name)

Federated Queues
- load-balance messages across federated queues
- only move messages when needed
